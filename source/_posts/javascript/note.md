---
title: EC和作用域链
date: 2020-08-18 20:45:17
categories:
  - Javascript
tags:
  - 学习笔记
---

# 代码段

每个script标签都会创建一个独立的作用域，每个script标签中的代码都会运行在它自己的作用域中，它们不会互相影响。
后执行script标签中的代码可以访问到先执行script标签中的变量，但是反过来不行。

# 预编译

在代码执行之前，浏览器会进行预编译，预编译会提前处理函数声明和变量声明，但是不会处理函数表达式和变量表达式。

## 声明提升

* 函数声明 整体提升 
* 函数表达式 不会提升 相当于变量声明
* 变量声明 只提升变量名，不会提升变量值
* 函数内部的局部变量，在函数内提升
* 没有声明语句，不会提升
  
```js
// 变量提升，但不会提升变量值
console.log(a); // undefined
var a = 2;
console.log(a); // 2

由于函数声明提升，这里可以执行
foo();

function foo() {
  console.log('foo fn')
}


fn() // Uncaught TypeError: fn is not a function
// 只提升声明，不会提升函数体
var fn = function() {}

var a = 2;
function foo1() {
    var b = 3;

    console.log("a:", a); // undefined 内部的 var a = 4; 提升了，但是没有赋值
    console.log("b:", b); // 3
    var a = 4;

}
```

# 执行上下文
执行上下文是js引擎执行代码的环境，每个执行上下文都有一个与之关联的变量对象（variable object），执行上下文中的代码在执行时，会访问这个变量对象中的变量和函数声明。
执行上下文分为三种：全局执行上下文、函数执行上下文、eval执行上下文。
执行上下文创建时会创建一个变量对象，用来存储变量和函数声明。
执行上下文会记录作用域链，用来确定当前执行代码对变量的访问权限。
执行上下文会处理this指向。

## EC（执行上下文）
### ECG（全局执行上下文）
script标签中的代码执行时，会创建一个全局执行上下文，全局执行上下文会一直存在，直到页面关闭。全局执行上下文只有一个，所以全局执行上下文中的变量和函数声明都会被提升到作用域的最顶端。
### ECF（函数执行上下文）
函数执行时，会创建一个函数执行上下文，函数执行上下文会随着函数执行结束而销毁。函数执行上下文可以有多个，因为函数可以被调用多次。
### ECStack（执行上下文栈）
执行上下文都会放到一个执行上下文栈中，栈底永远是全局执行上下文，栈顶永远是当前正在执行的上下文。
调用函数时，会创建一个函数执行上下文并压入栈顶，函数执行结束后，会弹出栈顶的函数执行上下文。

### 流程

代码执行前，会创建一个GO/VO，用来存储变量和函数声明。也就是变量和作用域提升（hoisting）
代码执行中，对GO/VO中的变量进行赋值或者执行函数。
当调用一个函数就会产生一个ECF，ECF中会创建一个VO，用来存储函数中的变量和函数声明。

1. 创建全局执行上下文和GO，压入栈顶
2. 调用一个函数，创建函数执行上下文和VO（AO），压入栈顶
3. 函数调用结束，函数执行上下文出栈
4. 代码执行结束，全局执行上下文出栈
   
## GO/VO（全局对象/变量对象）
全局执行上下文中的变量对象，就是全局对象。 浏览器中就是window对象。nodejs中是global对象。


# this指向

## 默认绑定

独立函数调用，this指向全局对象。

## 隐式绑定

函数作为对象的方法调用，this指向调用该方法的对象。

## 显式绑定

call、apply、bind

## new绑定



## 箭头函数